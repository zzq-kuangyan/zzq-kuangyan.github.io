---

程序 内存 进程 线程 浏览器和JavaScript和事件循环
---



### 进制数小知识点

二进制 是 通过 10101010组成 

八进制 通过 0 - 7 组成

十进制 通过  0 - 9 组成 

十六进制通过 0 - 9 a- f 组成

### 什么是程序

就是 app 和 电脑桌面上的 一些应用

### 什么是内存

这里的内存指的是 运行内存  不是 存储内存 cpu 会直接 读取 运行内存;

为什么要有 运行内存 cpu 直接在 存储内存 上读写 不更好吗 而且 内存空间大?

```bash
如果cpu  直接读取 存储内存 非常慢 而且 存储内存的空间非常大
```

### 什么是进程

什么是进程？；

进程就是 我们 打开一个程序 内存空间 会给这个程序分配一个空间 运行进程

### 什么是线程

线程就是 在分配好的进程空间里面 由线程来运行这些 一个 程序 进程最少有一个线程(叫做主线程)
（而浏览器是非常复杂的 浏览器 有多个进程） 浏览器最主要的三个进程 浏览器进程 网络进程 和 渲染进程

### 程序 内存 进程 程序 线程  介绍

 电脑桌面上对应的程序 当我们打开 程序的时候运行内存 会给 程序分配一片空间 叫 进程 每个 程序的进程空间 都是相互独立的 每个进程都最少有 一个 线程叫做主线程 来 运行这些代码

### 浏览器进程

 浏览器 有三个 主要的进程 浏览器进程 渲染进程 和 网络进程

 而渲染主线程(渲染进程) 他 要 执行 css  html  js  所有的页面渲染

### 渲染进程

 渲染进程下面的 线程 有 GUI渲染线程 定时线程（定时器触发线程、）  和 交互线程（事件触发线程）

### 如何理解js异步（面试题）

（注意）不是浏览器线程  浏览器是 多线程的  但是 JavaScript（js） 是单线程语言

```bash
JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。果而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。
所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。
```

### 任务有优先级吗

任务没有优先级 在信息队列中先进先出
在信息队列中 有优先级的

根据W3C的最新解释

 1. 每个任务都有一个任务类型 比如 微任务 定时任务 和 交互任务， 同一个类型的任务必须在同一个队列里面，不同的任务可以分属于不同的任务队列 在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出执行
 2. 浏览器必须准备一个 微任务队列，微任务队列中的任务优先其他任务执行

 在目前 chrome 中 至少包含以下队列

   1. 微任务队列（优先级最高）
   2. 交互任务队列（优先级高）
   3. 延时任务队列（优先级中）

### 模型模拟（模拟）

渲染主线程 [任务1, 任务2, 任务3]

微任务队列 [排队1，排队2，]（优先级最高）

延时任务队列 [排队1，排队2] (优先级中)

交互任务 [排队1，排队2] (优先级高)

### 阐述一下 JavaScript 的事件循环（面试题）

```bash

事件循环 又叫做消息循环 是浏览器主线程的工作方式 在Chrome的源码中 开启一个 不会结束的for循环，每次循环从信息队列中取出第一个任务执行 而其他线程只需要在合适的时候加入队列末尾即可

根据 w3c官方解释：
 每个任务都有一个任务类型 比如 微任务 定时任务 和 交互任务， 同一个类型的任务必须在同一个队列里面，不同的任务可以分属于不同的任务队列 在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出执行

```

### js中的计时器中 能做到精确计时吗 为什么

不能 因为:

1. 在受 事件循环的影响，计时的回调函数 只能在主线程空闲时间运行，因此带来偏差
2. 在w3c标准中，计时器 超过 五层 就会出现 4毫秒的最少时间，（简单解释）
完整解释：按照W3C标准，浏览器计时时，如果嵌套层级超过五层，则会带来4毫秒的最少时间，这样在计时时间少于4毫秒时又带来偏差

# 重新整理 浏览器进程和线程

浏览器进程：浏览器有六个进程分别

|进程名称 |数量 |进程介绍|
|-------|-------|-------|
|浏览器主进程(Browser)|1|主要负责进程管理，操作界面显示，用户的交互|
|网络进程|1|负责网络资源加载|
|渲染进程（浏览器内核Renderer进程内部是多线程）|N|负责将 HTML、CSS 和 JavaScript 转换成用户可以交互的操作界面。默认情况下，每个Tab都会被创建一个渲染进程。且渲染进程运行在沙箱模式下。|
|GPU进程|1|负责3D效果、动画、图片等渲染。|
|插件进程|N|负责插件的运行和隔离。隔离插件主要是防止出现单个插件崩溃导致页面或者浏览器崩溃的情况。|
|缓存进程(Storage Service)|1| 负责提供浏览器存储的功能。他是从主进程中分离出来的服务|
|音频进程(Audio Service)|1|主要处理 音频和视频|
|数字解码进程(Data Decoder Service)|N|执行image，zip等文件的解码|

重点是浏览器内核（渲染进程）

1. `GUI进程`
    负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
    当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
    注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

2. `JS引擎线程`
   也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
   JS引擎线程负责解析Javascript脚本，运行代码。
   JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
   同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

3. `事件触发线程`
   归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
   当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
   当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
   注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

4. `定时器线程`
    传说中的setInterval与setTimeout所在线程
    浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
    因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
    注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。

5. `异步http请求线程`
   在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
   将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。

WebWorker，JS的多线程？

 1. 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）
 2. S引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）

所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，
只待计算出结果后，将结果通信给主线程即可，perfect!

而且注意下，JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。

更多详细[https://segmentfault.com/a/1190000012925872#item-4-2]

关于defer和async

正常引入JavaScrip JS引擎线程执行的时，GUI线程会被挂起，所以像下图展示效果先html 解析 遇到script 下载对应的资源下载后解析资源，再重新执行渲染HTML

![](https://img.kancloud.cn/81/3e/813eafdcbccd1942f5be0380b56d35b2_716x184.png)

Async -- 异步

async 运行在浏览器执行其他操作时并行去下载指定js文件一旦文件的下载完成，浏览器将立即开始执行它。因此只要文件下载完 JS 文件的执行将阻止网页/HTML 文件的当前渲染。'简单'的说解决下载，让下载和其他操作可以同步，但当下载完成后的立即执行效果依旧会阻止'html' 渲染

async不会能保证在DOMContentLoaded之前或者之后执行

![](https://img.kancloud.cn/79/91/799186d005394b15600cb7e97fed8562_599x168.png)

Async 只是会同步去下载js文件 还是 会执行 javascript 组织 html渲染

defer-- 延迟（常用重要）

1.defer 属性的 JS 文件将与其他文件同时下载，仅在 HTML 文件呈现完成后才开始执行下载的资
源，而不是像 async 在资源下载完成后立即执行。 因此，延迟文件的下载和执行都不会阻塞渲
染。
2.defer 加载顺序将始终按照指定
3. 它会等待DOM Tree构建完成，在DOMContentLoaded事件之前先执行defer中的代码
4. 并不会产生所谓的获取不到dom到情况

注释：DOMContentLoaded是html页面生命周期 会在DOM树执行完毕就执行, onload 在 dom构建完成 并且完成了所有的图片 样式表 脚本等资源加载完成后触发

![](https://img.kancloud.cn/cf/03/cf03cd6f810ad0ec78e7d83d5279c7a3_644x204.png)
